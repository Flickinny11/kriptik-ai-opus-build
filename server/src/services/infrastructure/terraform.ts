/**
 * Terraform/IaC Service
 *
 * Infrastructure as Code generation and management for:
 * - Custom containerized applications
 * - Docker image building and pushing
 * - Cloud provisioning (AWS, GCP, Azure)
 * - Kubernetes deployments
 *
 * Workflow:
 * 1. User describes their app requirements
 * 2. KripTik generates Dockerfile and Terraform configs
 * 3. Docker image is built and pushed to registry
 * 4. Terraform provisions cloud resources
 * 5. App is deployed and URL is returned
 */

import { v4 as uuidv4 } from 'uuid';
import { db } from '../../db.js';
import { deployments } from '../../schema.js';

// ============================================================================
// TYPES
// ============================================================================

export interface TerraformConfig {
    awsAccessKeyId?: string;
    awsSecretAccessKey?: string;
    awsRegion?: string;
    gcpProjectId?: string;
    gcpCredentialsJson?: string;
    azureSubscriptionId?: string;
    azureClientId?: string;
    azureClientSecret?: string;
    azureTenantId?: string;
    dockerHubUsername?: string;
    dockerHubToken?: string;
}

export interface ContainerSpec {
    name: string;
    baseImage: string;
    workdir?: string;
    copyFiles?: Array<{ src: string; dest: string }>;
    runCommands?: string[];
    envVars?: Record<string, string>;
    ports?: number[];
    entrypoint?: string[];
    cmd?: string[];
    healthCheck?: {
        cmd: string;
        interval?: string;
        timeout?: string;
        retries?: number;
    };
}

export interface InfrastructureSpec {
    provider: 'aws' | 'gcp' | 'azure';
    region: string;
    // Compute
    instanceType?: string;
    gpuType?: string;
    // Scaling
    minInstances?: number;
    maxInstances?: number;
    // Networking
    enableHttps?: boolean;
    customDomain?: string;
    // Database
    database?: {
        type: 'postgres' | 'mysql' | 'mongodb' | 'redis';
        size: 'small' | 'medium' | 'large';
    };
    // Storage
    storage?: {
        type: 's3' | 'gcs' | 'blob';
        sizeGb: number;
    };
}

export interface DeploymentRequest {
    projectId: string;
    userId: string;
    appName: string;
    container: ContainerSpec;
    infrastructure: InfrastructureSpec;
    // Source files to containerize
    files?: Record<string, string>;
}

export interface GeneratedInfrastructure {
    dockerfile: string;
    terraformMain: string;
    terraformVariables: string;
    terraformOutputs: string;
    dockerCompose?: string;
    kubernetesManifest?: string;
    buildInstructions: string;
    estimatedMonthlyCost: number;
}

// ============================================================================
// TERRAFORM TEMPLATES
// ============================================================================

const AWS_ECS_TEMPLATE = `
# AWS ECS Fargate Deployment
# Generated by KripTik AI

terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

provider "aws" {
  region = var.aws_region
}

# VPC
resource "aws_vpc" "main" {
  cidr_block           = "10.0.0.0/16"
  enable_dns_hostnames = true
  enable_dns_support   = true
  
  tags = {
    Name = "\${var.app_name}-vpc"
    ManagedBy = "kriptik-ai"
  }
}

# Subnets
resource "aws_subnet" "public" {
  count                   = 2
  vpc_id                  = aws_vpc.main.id
  cidr_block              = "10.0.\${count.index + 1}.0/24"
  availability_zone       = data.aws_availability_zones.available.names[count.index]
  map_public_ip_on_launch = true
  
  tags = {
    Name = "\${var.app_name}-public-\${count.index + 1}"
  }
}

data "aws_availability_zones" "available" {
  state = "available"
}

# Internet Gateway
resource "aws_internet_gateway" "main" {
  vpc_id = aws_vpc.main.id
  
  tags = {
    Name = "\${var.app_name}-igw"
  }
}

# Route Table
resource "aws_route_table" "public" {
  vpc_id = aws_vpc.main.id
  
  route {
    cidr_block = "0.0.0.0/0"
    gateway_id = aws_internet_gateway.main.id
  }
  
  tags = {
    Name = "\${var.app_name}-public-rt"
  }
}

resource "aws_route_table_association" "public" {
  count          = 2
  subnet_id      = aws_subnet.public[count.index].id
  route_table_id = aws_route_table.public.id
}

# Security Group
resource "aws_security_group" "app" {
  name        = "\${var.app_name}-sg"
  description = "Security group for \${var.app_name}"
  vpc_id      = aws_vpc.main.id
  
  ingress {
    from_port   = var.container_port
    to_port     = var.container_port
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }
  
  ingress {
    from_port   = 443
    to_port     = 443
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }
  
  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }
}

# ECR Repository
resource "aws_ecr_repository" "app" {
  name                 = var.app_name
  image_tag_mutability = "MUTABLE"
  
  image_scanning_configuration {
    scan_on_push = true
  }
}

# ECS Cluster
resource "aws_ecs_cluster" "main" {
  name = "\${var.app_name}-cluster"
  
  setting {
    name  = "containerInsights"
    value = "enabled"
  }
}

# ECS Task Definition
resource "aws_ecs_task_definition" "app" {
  family                   = var.app_name
  network_mode             = "awsvpc"
  requires_compatibilities = ["FARGATE"]
  cpu                      = var.cpu
  memory                   = var.memory
  execution_role_arn       = aws_iam_role.ecs_execution.arn
  task_role_arn           = aws_iam_role.ecs_task.arn
  
  container_definitions = jsonencode([{
    name  = var.app_name
    image = "\${aws_ecr_repository.app.repository_url}:latest"
    
    portMappings = [{
      containerPort = var.container_port
      protocol      = "tcp"
    }]
    
    environment = [
      for k, v in var.environment_variables : {
        name  = k
        value = v
      }
    ]
    
    logConfiguration = {
      logDriver = "awslogs"
      options = {
        "awslogs-group"         = aws_cloudwatch_log_group.app.name
        "awslogs-region"        = var.aws_region
        "awslogs-stream-prefix" = "ecs"
      }
    }
  }])
}

# CloudWatch Log Group
resource "aws_cloudwatch_log_group" "app" {
  name              = "/ecs/\${var.app_name}"
  retention_in_days = 30
}

# IAM Roles
resource "aws_iam_role" "ecs_execution" {
  name = "\${var.app_name}-ecs-execution"
  
  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [{
      Action = "sts:AssumeRole"
      Effect = "Allow"
      Principal = {
        Service = "ecs-tasks.amazonaws.com"
      }
    }]
  })
}

resource "aws_iam_role_policy_attachment" "ecs_execution" {
  role       = aws_iam_role.ecs_execution.name
  policy_arn = "arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy"
}

resource "aws_iam_role" "ecs_task" {
  name = "\${var.app_name}-ecs-task"
  
  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [{
      Action = "sts:AssumeRole"
      Effect = "Allow"
      Principal = {
        Service = "ecs-tasks.amazonaws.com"
      }
    }]
  })
}

# ECS Service
resource "aws_ecs_service" "app" {
  name            = var.app_name
  cluster         = aws_ecs_cluster.main.id
  task_definition = aws_ecs_task_definition.app.arn
  desired_count   = var.min_instances
  launch_type     = "FARGATE"
  
  network_configuration {
    subnets          = aws_subnet.public[*].id
    security_groups  = [aws_security_group.app.id]
    assign_public_ip = true
  }
  
  load_balancer {
    target_group_arn = aws_lb_target_group.app.arn
    container_name   = var.app_name
    container_port   = var.container_port
  }
  
  depends_on = [aws_lb_listener.app]
}

# Application Load Balancer
resource "aws_lb" "app" {
  name               = "\${var.app_name}-alb"
  internal           = false
  load_balancer_type = "application"
  security_groups    = [aws_security_group.app.id]
  subnets            = aws_subnet.public[*].id
}

resource "aws_lb_target_group" "app" {
  name        = "\${var.app_name}-tg"
  port        = var.container_port
  protocol    = "HTTP"
  vpc_id      = aws_vpc.main.id
  target_type = "ip"
  
  health_check {
    path                = "/health"
    healthy_threshold   = 2
    unhealthy_threshold = 10
    timeout             = 60
    interval            = 300
    matcher             = "200"
  }
}

resource "aws_lb_listener" "app" {
  load_balancer_arn = aws_lb.app.arn
  port              = 80
  protocol          = "HTTP"
  
  default_action {
    type             = "forward"
    target_group_arn = aws_lb_target_group.app.arn
  }
}

# Auto Scaling
resource "aws_appautoscaling_target" "ecs" {
  max_capacity       = var.max_instances
  min_capacity       = var.min_instances
  resource_id        = "service/\${aws_ecs_cluster.main.name}/\${aws_ecs_service.app.name}"
  scalable_dimension = "ecs:service:DesiredCount"
  service_namespace  = "ecs"
}

resource "aws_appautoscaling_policy" "ecs_cpu" {
  name               = "\${var.app_name}-cpu-scaling"
  policy_type        = "TargetTrackingScaling"
  resource_id        = aws_appautoscaling_target.ecs.resource_id
  scalable_dimension = aws_appautoscaling_target.ecs.scalable_dimension
  service_namespace  = aws_appautoscaling_target.ecs.service_namespace
  
  target_tracking_scaling_policy_configuration {
    target_value       = 70.0
    scale_in_cooldown  = 300
    scale_out_cooldown = 60
    
    predefined_metric_specification {
      predefined_metric_type = "ECSServiceAverageCPUUtilization"
    }
  }
}
`;

const GCP_CLOUD_RUN_TEMPLATE = `
# GCP Cloud Run Deployment
# Generated by KripTik AI

terraform {
  required_providers {
    google = {
      source  = "hashicorp/google"
      version = "~> 5.0"
    }
  }
}

provider "google" {
  project = var.gcp_project_id
  region  = var.gcp_region
}

# Artifact Registry Repository
resource "google_artifact_registry_repository" "app" {
  location      = var.gcp_region
  repository_id = var.app_name
  format        = "DOCKER"
  
  labels = {
    managed_by = "kriptik-ai"
  }
}

# Cloud Run Service
resource "google_cloud_run_v2_service" "app" {
  name     = var.app_name
  location = var.gcp_region
  
  template {
    containers {
      image = "\${var.gcp_region}-docker.pkg.dev/\${var.gcp_project_id}/\${var.app_name}/\${var.app_name}:latest"
      
      ports {
        container_port = var.container_port
      }
      
      resources {
        limits = {
          cpu    = var.cpu
          memory = var.memory
        }
      }
      
      dynamic "env" {
        for_each = var.environment_variables
        content {
          name  = env.key
          value = env.value
        }
      }
    }
    
    scaling {
      min_instance_count = var.min_instances
      max_instance_count = var.max_instances
    }
  }
  
  traffic {
    type    = "TRAFFIC_TARGET_ALLOCATION_TYPE_LATEST"
    percent = 100
  }
}

# Allow unauthenticated access (public API)
resource "google_cloud_run_v2_service_iam_member" "public" {
  name     = google_cloud_run_v2_service.app.name
  location = google_cloud_run_v2_service.app.location
  role     = "roles/run.invoker"
  member   = "allUsers"
}
`;

// ============================================================================
// SERVICE
// ============================================================================

export class TerraformService {
    private config: TerraformConfig;

    constructor(config: TerraformConfig) {
        this.config = config;
    }

    /**
     * Generate complete infrastructure for a deployment
     */
    generateInfrastructure(request: DeploymentRequest): GeneratedInfrastructure {
        const dockerfile = this.generateDockerfile(request.container);
        const terraformMain = this.generateTerraformMain(request.infrastructure, request.appName);
        const terraformVariables = this.generateTerraformVariables(request.infrastructure, request.appName, request.container);
        const terraformOutputs = this.generateTerraformOutputs(request.infrastructure);
        const dockerCompose = this.generateDockerCompose(request.container, request.appName);
        const kubernetesManifest = this.generateKubernetesManifest(request.container, request.infrastructure, request.appName);
        const buildInstructions = this.generateBuildInstructions(request);
        const estimatedMonthlyCost = this.estimateMonthlyCost(request.infrastructure);

        return {
            dockerfile,
            terraformMain,
            terraformVariables,
            terraformOutputs,
            dockerCompose,
            kubernetesManifest,
            buildInstructions,
            estimatedMonthlyCost,
        };
    }

    /**
     * Generate Dockerfile
     */
    generateDockerfile(container: ContainerSpec): string {
        const lines: string[] = [];

        lines.push(`# Dockerfile generated by KripTik AI`);
        lines.push(`FROM ${container.baseImage}`);
        lines.push('');

        if (container.workdir) {
            lines.push(`WORKDIR ${container.workdir}`);
            lines.push('');
        }

        // Environment variables
        if (container.envVars) {
            for (const [key, value] of Object.entries(container.envVars)) {
                lines.push(`ENV ${key}="${value}"`);
            }
            lines.push('');
        }

        // Copy files
        if (container.copyFiles) {
            for (const file of container.copyFiles) {
                lines.push(`COPY ${file.src} ${file.dest}`);
            }
            lines.push('');
        }

        // Run commands
        if (container.runCommands) {
            for (const cmd of container.runCommands) {
                lines.push(`RUN ${cmd}`);
            }
            lines.push('');
        }

        // Expose ports
        if (container.ports) {
            for (const port of container.ports) {
                lines.push(`EXPOSE ${port}`);
            }
            lines.push('');
        }

        // Health check
        if (container.healthCheck) {
            const hc = container.healthCheck;
            let healthCheckLine = `HEALTHCHECK`;
            if (hc.interval) healthCheckLine += ` --interval=${hc.interval}`;
            if (hc.timeout) healthCheckLine += ` --timeout=${hc.timeout}`;
            if (hc.retries) healthCheckLine += ` --retries=${hc.retries}`;
            healthCheckLine += ` CMD ${hc.cmd}`;
            lines.push(healthCheckLine);
            lines.push('');
        }

        // Entrypoint and CMD
        if (container.entrypoint) {
            lines.push(`ENTRYPOINT [${container.entrypoint.map(e => `"${e}"`).join(', ')}]`);
        }
        if (container.cmd) {
            lines.push(`CMD [${container.cmd.map(c => `"${c}"`).join(', ')}]`);
        }

        return lines.join('\n');
    }

    /**
     * Generate Terraform main.tf
     */
    generateTerraformMain(infra: InfrastructureSpec, appName: string): string {
        if (infra.provider === 'aws') {
            return AWS_ECS_TEMPLATE;
        } else if (infra.provider === 'gcp') {
            return GCP_CLOUD_RUN_TEMPLATE;
        }

        // Default AWS
        return AWS_ECS_TEMPLATE;
    }

    /**
     * Generate Terraform variables.tf
     */
    generateTerraformVariables(
        infra: InfrastructureSpec,
        appName: string,
        container: ContainerSpec
    ): string {
        const lines: string[] = [];
        lines.push('# Variables generated by KripTik AI');
        lines.push('');

        // Common variables
        lines.push(`variable "app_name" {
  description = "Application name"
  type        = string
  default     = "${appName}"
}`);
        lines.push('');

        lines.push(`variable "container_port" {
  description = "Container port"
  type        = number
  default     = ${container.ports?.[0] || 8080}
}`);
        lines.push('');

        lines.push(`variable "min_instances" {
  description = "Minimum instances"
  type        = number
  default     = ${infra.minInstances || 1}
}`);
        lines.push('');

        lines.push(`variable "max_instances" {
  description = "Maximum instances"
  type        = number
  default     = ${infra.maxInstances || 10}
}`);
        lines.push('');

        lines.push(`variable "environment_variables" {
  description = "Environment variables"
  type        = map(string)
  default     = ${JSON.stringify(container.envVars || {}, null, 2).replace(/\n/g, '\n  ')}
}`);
        lines.push('');

        // Provider-specific variables
        if (infra.provider === 'aws') {
            lines.push(`variable "aws_region" {
  description = "AWS Region"
  type        = string
  default     = "${infra.region || 'us-east-1'}"
}`);
            lines.push('');

            lines.push(`variable "cpu" {
  description = "Task CPU units"
  type        = string
  default     = "${infra.instanceType === 'large' ? '2048' : '256'}"
}`);
            lines.push('');

            lines.push(`variable "memory" {
  description = "Task memory (MiB)"
  type        = string
  default     = "${infra.instanceType === 'large' ? '4096' : '512'}"
}`);
        } else if (infra.provider === 'gcp') {
            lines.push(`variable "gcp_project_id" {
  description = "GCP Project ID"
  type        = string
}`);
            lines.push('');

            lines.push(`variable "gcp_region" {
  description = "GCP Region"
  type        = string
  default     = "${infra.region || 'us-central1'}"
}`);
            lines.push('');

            lines.push(`variable "cpu" {
  description = "CPU limit"
  type        = string
  default     = "${infra.instanceType === 'large' ? '2' : '1'}"
}`);
            lines.push('');

            lines.push(`variable "memory" {
  description = "Memory limit"
  type        = string
  default     = "${infra.instanceType === 'large' ? '4Gi' : '512Mi'}"
}`);
        }

        return lines.join('\n');
    }

    /**
     * Generate Terraform outputs.tf
     */
    generateTerraformOutputs(infra: InfrastructureSpec): string {
        const lines: string[] = [];
        lines.push('# Outputs generated by KripTik AI');
        lines.push('');

        if (infra.provider === 'aws') {
            lines.push(`output "app_url" {
  description = "Application URL"
  value       = "http://\${aws_lb.app.dns_name}"
}`);
            lines.push('');

            lines.push(`output "ecr_repository_url" {
  description = "ECR Repository URL"
  value       = aws_ecr_repository.app.repository_url
}`);
        } else if (infra.provider === 'gcp') {
            lines.push(`output "app_url" {
  description = "Application URL"
  value       = google_cloud_run_v2_service.app.uri
}`);
            lines.push('');

            lines.push(`output "artifact_registry_url" {
  description = "Artifact Registry URL"
  value       = "\${var.gcp_region}-docker.pkg.dev/\${var.gcp_project_id}/\${var.app_name}"
}`);
        }

        return lines.join('\n');
    }

    /**
     * Generate Docker Compose for local development
     */
    generateDockerCompose(container: ContainerSpec, appName: string): string {
        const compose = {
            version: '3.8',
            services: {
                [appName]: {
                    build: '.',
                    ports: container.ports?.map(p => `${p}:${p}`) || ['8080:8080'],
                    environment: container.envVars || {},
                    restart: 'unless-stopped',
                },
            },
        };

        return `# Docker Compose generated by KripTik AI\n${JSON.stringify(compose, null, 2).replace(/"([^"]+)":/g, '$1:')}`;
    }

    /**
     * Generate Kubernetes manifest
     */
    generateKubernetesManifest(
        container: ContainerSpec,
        infra: InfrastructureSpec,
        appName: string
    ): string {
        return `
# Kubernetes Deployment generated by KripTik AI
apiVersion: apps/v1
kind: Deployment
metadata:
  name: ${appName}
  labels:
    app: ${appName}
    managed-by: kriptik-ai
spec:
  replicas: ${infra.minInstances || 1}
  selector:
    matchLabels:
      app: ${appName}
  template:
    metadata:
      labels:
        app: ${appName}
    spec:
      containers:
      - name: ${appName}
        image: ${appName}:latest
        ports:
        - containerPort: ${container.ports?.[0] || 8080}
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "${infra.instanceType === 'large' ? '4Gi' : '512Mi'}"
            cpu: "${infra.instanceType === 'large' ? '2' : '1'}"
        env:
${Object.entries(container.envVars || {}).map(([k, v]) => `        - name: ${k}\n          value: "${v}"`).join('\n')}
---
apiVersion: v1
kind: Service
metadata:
  name: ${appName}
spec:
  selector:
    app: ${appName}
  ports:
  - port: 80
    targetPort: ${container.ports?.[0] || 8080}
  type: LoadBalancer
---
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: ${appName}
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: ${appName}
  minReplicas: ${infra.minInstances || 1}
  maxReplicas: ${infra.maxInstances || 10}
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
`.trim();
    }

    /**
     * Generate build instructions
     */
    generateBuildInstructions(request: DeploymentRequest): string {
        const { appName, infrastructure } = request;

        return `
# Deployment Instructions for ${appName}
Generated by KripTik AI

## Prerequisites

1. Install Docker: https://docs.docker.com/get-docker/
2. Install Terraform: https://www.terraform.io/downloads
3. Configure cloud credentials

## Step 1: Build Docker Image

\`\`\`bash
# Build the image
docker build -t ${appName}:latest .

# Test locally
docker run -p 8080:8080 ${appName}:latest
\`\`\`

## Step 2: Push to Container Registry

${infrastructure.provider === 'aws' ? `
### AWS ECR
\`\`\`bash
# Login to ECR
aws ecr get-login-password --region ${infrastructure.region} | docker login --username AWS --password-stdin YOUR_ACCOUNT_ID.dkr.ecr.${infrastructure.region}.amazonaws.com

# Tag and push
docker tag ${appName}:latest YOUR_ACCOUNT_ID.dkr.ecr.${infrastructure.region}.amazonaws.com/${appName}:latest
docker push YOUR_ACCOUNT_ID.dkr.ecr.${infrastructure.region}.amazonaws.com/${appName}:latest
\`\`\`
` : `
### GCP Artifact Registry
\`\`\`bash
# Configure Docker for GCP
gcloud auth configure-docker ${infrastructure.region}-docker.pkg.dev

# Tag and push
docker tag ${appName}:latest ${infrastructure.region}-docker.pkg.dev/YOUR_PROJECT/${appName}/${appName}:latest
docker push ${infrastructure.region}-docker.pkg.dev/YOUR_PROJECT/${appName}/${appName}:latest
\`\`\`
`}

## Step 3: Deploy Infrastructure

\`\`\`bash
# Initialize Terraform
terraform init

# Preview changes
terraform plan

# Apply changes
terraform apply
\`\`\`

## Step 4: Verify Deployment

After deployment, Terraform will output your application URL.

\`\`\`bash
terraform output app_url
\`\`\`

## Cleanup

To destroy all resources:
\`\`\`bash
terraform destroy
\`\`\`
`.trim();
    }

    /**
     * Estimate monthly cost
     */
    estimateMonthlyCost(infra: InfrastructureSpec): number {
        const minInstances = infra.minInstances || 1;
        const hoursPerMonth = 730;

        let hourlyRate = 0.02; // Base rate

        if (infra.provider === 'aws') {
            // AWS Fargate pricing varies by region and size
            hourlyRate = infra.instanceType === 'large' ? 0.08 : 0.02;
        } else if (infra.provider === 'gcp') {
            // Cloud Run pricing
            hourlyRate = infra.instanceType === 'large' ? 0.06 : 0.015;
        }

        if (infra.gpuType) {
            hourlyRate += 0.50; // GPU premium
        }

        const computeCost = hourlyRate * hoursPerMonth * minInstances;
        const networkCost = 10; // Estimated egress
        const storageCost = infra.storage ? infra.storage.sizeGb * 0.10 : 0;
        const databaseCost = infra.database
            ? { small: 25, medium: 100, large: 400 }[infra.database.size] || 0
            : 0;

        return Math.round((computeCost + networkCost + storageCost + databaseCost) * 100) / 100;
    }

    /**
     * Save deployment to database
     */
    async saveDeployment(
        request: DeploymentRequest,
        generated: GeneratedInfrastructure
    ): Promise<string> {
        const id = uuidv4();

        await db.insert(deployments).values({
            id,
            projectId: request.projectId,
            userId: request.userId,
            provider: request.infrastructure.provider,
            resourceType: 'containerized-app',
            config: {
                appName: request.appName,
                container: request.container,
                infrastructure: request.infrastructure,
                generatedFiles: {
                    dockerfile: true,
                    terraform: true,
                    kubernetes: true,
                },
            },
            status: 'pending',
            estimatedMonthlyCost: generated.estimatedMonthlyCost,
        });

        return id;
    }
}

// ============================================================================
// FACTORY
// ============================================================================

export function createTerraformService(config: TerraformConfig): TerraformService {
    return new TerraformService(config);
}

