/**
 * Docker Container Builder
 *
 * Build and deploy custom Docker containers for AI workloads
 */

import { CloudProvider, GPUType } from '../cloud/types.js';

// Base images for different use cases
export const BASE_IMAGES = {
    // NVIDIA CUDA images
    cuda118: 'nvidia/cuda:11.8.0-cudnn8-runtime-ubuntu22.04',
    cuda121: 'nvidia/cuda:12.1.0-cudnn8-runtime-ubuntu22.04',
    cuda122: 'nvidia/cuda:12.2.0-cudnn8-runtime-ubuntu22.04',

    // Python ML images
    pytorch2: 'pytorch/pytorch:2.1.0-cuda12.1-cudnn8-runtime',
    tensorflow: 'tensorflow/tensorflow:2.15.0-gpu',

    // HuggingFace images
    transformers: 'huggingface/transformers-pytorch-gpu:latest',
    diffusers: 'huggingface/diffusers-pytorch-cuda:latest',

    // ComfyUI
    comfyui: 'comfyanonymous/comfyui:latest',

    // Minimal Python
    python311: 'python:3.11-slim',
    python310: 'python:3.10-slim',

    // Node.js
    node20: 'node:20-slim',
    node18: 'node:18-slim',
};

export type BaseImage = keyof typeof BASE_IMAGES;

export interface DockerBuildConfig {
    name: string;
    baseImage: BaseImage | string;

    // Package management
    pythonPackages?: string[];
    npmPackages?: string[];
    aptPackages?: string[];

    // Files to copy
    files?: Array<{
        source: string;
        destination: string;
    }>;

    // Commands
    runCommands?: string[];
    entrypoint?: string[];
    cmd?: string[];

    // Environment
    env?: Record<string, string>;

    // Ports
    exposePorts?: number[];

    // Working directory
    workdir?: string;

    // Health check
    healthcheck?: {
        cmd: string;
        interval?: string;
        timeout?: string;
        retries?: number;
    };

    // GPU settings
    gpu?: {
        type: GPUType;
        cudaVersion?: string;
    };

    // Labels
    labels?: Record<string, string>;
}

export interface DockerBuildResult {
    dockerfile: string;
    buildScript: string;
    requirements?: string;
    packageJson?: string;
}

/**
 * Docker Builder Service
 */
export class DockerBuilderService {
    /**
     * Generate Dockerfile from configuration
     */
    generateDockerfile(config: DockerBuildConfig): DockerBuildResult {
        const baseImage = BASE_IMAGES[config.baseImage as BaseImage] || config.baseImage;

        let dockerfile = `# Auto-generated Dockerfile
# Generated by KripTik AI
# Name: ${config.name}

FROM ${baseImage}

`;

        // Labels
        dockerfile += `LABEL maintainer="kriptik-ai"\n`;
        dockerfile += `LABEL app="${config.name}"\n`;
        if (config.labels) {
            for (const [key, value] of Object.entries(config.labels)) {
                dockerfile += `LABEL ${key}="${value}"\n`;
            }
        }
        dockerfile += '\n';

        // Working directory
        dockerfile += `WORKDIR ${config.workdir || '/app'}\n\n`;

        // APT packages
        if (config.aptPackages && config.aptPackages.length > 0) {
            dockerfile += `# Install system dependencies
RUN apt-get update && apt-get install -y --no-install-recommends \\
    ${config.aptPackages.join(' \\\n    ')} \\
    && rm -rf /var/lib/apt/lists/*

`;
        }

        // Python packages
        let requirementsTxt: string | undefined;
        if (config.pythonPackages && config.pythonPackages.length > 0) {
            requirementsTxt = config.pythonPackages.join('\n');
            dockerfile += `# Install Python dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

`;
        }

        // NPM packages
        let packageJson: string | undefined;
        if (config.npmPackages && config.npmPackages.length > 0) {
            const deps: Record<string, string> = {};
            for (const pkg of config.npmPackages) {
                const [name, version] = pkg.split('@');
                deps[name] = version || 'latest';
            }
            packageJson = JSON.stringify({
                name: config.name,
                version: '1.0.0',
                dependencies: deps,
            }, null, 2);

            dockerfile += `# Install Node.js dependencies
COPY package.json .
RUN npm install --production

`;
        }

        // Custom run commands
        if (config.runCommands && config.runCommands.length > 0) {
            dockerfile += `# Custom setup commands\n`;
            for (const cmd of config.runCommands) {
                dockerfile += `RUN ${cmd}\n`;
            }
            dockerfile += '\n';
        }

        // Copy files
        if (config.files && config.files.length > 0) {
            dockerfile += `# Copy application files\n`;
            for (const file of config.files) {
                dockerfile += `COPY ${file.source} ${file.destination}\n`;
            }
            dockerfile += '\n';
        }

        // Environment variables
        if (config.env) {
            dockerfile += `# Environment variables\n`;
            for (const [key, value] of Object.entries(config.env)) {
                dockerfile += `ENV ${key}="${value}"\n`;
            }
            dockerfile += '\n';
        }

        // Expose ports
        if (config.exposePorts && config.exposePorts.length > 0) {
            dockerfile += `# Expose ports\n`;
            for (const port of config.exposePorts) {
                dockerfile += `EXPOSE ${port}\n`;
            }
            dockerfile += '\n';
        }

        // Health check
        if (config.healthcheck) {
            dockerfile += `# Health check
HEALTHCHECK --interval=${config.healthcheck.interval || '30s'} \\
    --timeout=${config.healthcheck.timeout || '10s'} \\
    --retries=${config.healthcheck.retries || 3} \\
    CMD ${config.healthcheck.cmd}

`;
        }

        // Entrypoint and CMD
        if (config.entrypoint) {
            dockerfile += `ENTRYPOINT [${config.entrypoint.map(e => `"${e}"`).join(', ')}]\n`;
        }
        if (config.cmd) {
            dockerfile += `CMD [${config.cmd.map(c => `"${c}"`).join(', ')}]\n`;
        }

        // Generate build script
        const buildScript = this.generateBuildScript(config);

        return {
            dockerfile,
            buildScript,
            requirements: requirementsTxt,
            packageJson,
        };
    }

    /**
     * Generate build script for local testing
     */
    private generateBuildScript(config: DockerBuildConfig): string {
        const imageName = config.name.toLowerCase().replace(/[^a-z0-9-]/g, '-');

        return `#!/bin/bash
# Build script for ${config.name}
# Generated by KripTik AI

set -e

IMAGE_NAME="${imageName}"
TAG="latest"

echo "Building Docker image: \$IMAGE_NAME:\$TAG"

# Build the image
docker build -t \$IMAGE_NAME:\$TAG .

echo "Build complete!"

# Run locally for testing
echo "To run locally:"
echo "docker run -p ${config.exposePorts?.[0] || 8000}:${config.exposePorts?.[0] || 8000} ${config.gpu ? '--gpus all' : ''} \$IMAGE_NAME:\$TAG"
`;
    }

    /**
     * Generate Dockerfile for a Python inference server
     */
    generatePythonInferenceServer(config: {
        name: string;
        modelType: 'huggingface' | 'custom';
        modelId?: string;
        pythonVersion?: string;
        cudaVersion?: string;
        additionalPackages?: string[];
        serverCode: string;
    }): DockerBuildResult {
        const basePackages = [
            'torch>=2.0.0',
            'transformers>=4.35.0',
            'accelerate>=0.24.0',
            'safetensors>=0.4.0',
            'flask>=3.0.0',
            'gunicorn>=21.0.0',
            'pillow>=10.0.0',
        ];

        const buildConfig: DockerBuildConfig = {
            name: config.name,
            baseImage: config.cudaVersion ? `cuda${config.cudaVersion.replace('.', '')}` as BaseImage : 'pytorch2',
            pythonPackages: [...basePackages, ...(config.additionalPackages || [])],
            aptPackages: ['curl', 'git'],
            files: [
                { source: 'server.py', destination: './server.py' },
            ],
            env: {
                PYTHONUNBUFFERED: '1',
                MODEL_ID: config.modelId || '',
            },
            exposePorts: [8000],
            healthcheck: {
                cmd: 'curl -f http://localhost:8000/health || exit 1',
            },
            cmd: ['gunicorn', '-w', '1', '-b', '0.0.0.0:8000', '--timeout', '300', 'server:app'],
            gpu: {
                type: 'nvidia-rtx-4090',
                cudaVersion: config.cudaVersion,
            },
        };

        const result = this.generateDockerfile(buildConfig);

        return {
            ...result,
            // Include the server code as a separate file
        };
    }

    /**
     * Generate Dockerfile for ComfyUI with custom nodes
     */
    generateComfyUIContainer(config: {
        name: string;
        customNodes: string[];
        checkpoints?: string[];
        loras?: string[];
    }): DockerBuildResult {
        const customNodeCommands = config.customNodes.map(node => {
            const knownRepos: Record<string, string> = {
                'ComfyUI-Impact-Pack': 'https://github.com/ltdrdata/ComfyUI-Impact-Pack',
                'ComfyUI_IPAdapter_plus': 'https://github.com/cubiq/ComfyUI_IPAdapter_plus',
                'comfyui_controlnet_aux': 'https://github.com/Fannovel16/comfyui_controlnet_aux',
            };
            const repo = knownRepos[node];
            return repo
                ? `cd /comfyui/custom_nodes && git clone ${repo}`
                : `# Custom node not found: ${node}`;
        });

        const buildConfig: DockerBuildConfig = {
            name: config.name,
            baseImage: 'comfyui',
            aptPackages: ['curl', 'git'],
            runCommands: [
                ...customNodeCommands,
                'pip install flask gunicorn pillow',
            ],
            files: [
                { source: 'workflow.json', destination: '/comfyui/workflow.json' },
                { source: 'api_server.py', destination: '/comfyui/api_server.py' },
                { source: 'start.sh', destination: '/comfyui/start.sh' },
            ],
            exposePorts: [8000, 8188],
            healthcheck: {
                cmd: 'curl -f http://localhost:8000/health || exit 1',
            },
            entrypoint: ['/bin/bash'],
            cmd: ['/comfyui/start.sh'],
            gpu: {
                type: 'nvidia-rtx-4090',
            },
        };

        return this.generateDockerfile(buildConfig);
    }

    /**
     * Validate Dockerfile syntax
     */
    validateDockerfile(dockerfile: string): { valid: boolean; errors: string[] } {
        const errors: string[] = [];
        const lines = dockerfile.split('\n');

        let hasFrom = false;

        for (let i = 0; i < lines.length; i++) {
            const line = lines[i].trim();
            if (!line || line.startsWith('#')) continue;

            // Check for FROM instruction
            if (line.toUpperCase().startsWith('FROM ')) {
                hasFrom = true;
            }

            // Check for common mistakes
            if (line.toUpperCase().startsWith('RUN ') && line.includes('apt-get install')) {
                if (!line.includes('-y') && !line.includes('--yes')) {
                    errors.push(`Line ${i + 1}: apt-get install should use -y flag for non-interactive mode`);
                }
            }

            // Check for secrets in ENV
            if (line.toUpperCase().startsWith('ENV ')) {
                const envContent = line.substring(4).toLowerCase();
                if (envContent.includes('password') || envContent.includes('secret') || envContent.includes('api_key')) {
                    errors.push(`Line ${i + 1}: Avoid hardcoding secrets in Dockerfile. Use runtime environment variables.`);
                }
            }
        }

        if (!hasFrom) {
            errors.push('Dockerfile must start with FROM instruction');
        }

        return {
            valid: errors.length === 0,
            errors,
        };
    }

    /**
     * Estimate container resource requirements
     */
    estimateResources(config: DockerBuildConfig): {
        cpuCores: number;
        memoryGB: number;
        gpuMemoryGB?: number;
        storageGB: number;
    } {
        let cpuCores = 1;
        let memoryGB = 1;
        let gpuMemoryGB: number | undefined;
        let storageGB = 5;

        // GPU workloads
        if (config.gpu) {
            cpuCores = 4;
            memoryGB = 16;
            storageGB = 50;

            const gpuMemoryMap: Record<GPUType, number> = {
                'nvidia-rtx-3090': 24,
                'nvidia-rtx-4090': 24,
                'nvidia-a40': 48,
                'nvidia-a100-40gb': 40,
                'nvidia-a100-80gb': 80,
                'nvidia-h100': 80,
                'nvidia-l40': 48,
                'nvidia-t4': 16,
                'nvidia-v100': 16,
            };
            gpuMemoryGB = gpuMemoryMap[config.gpu.type] || 24;
        }

        // ML packages need more resources
        const mlPackages = ['torch', 'tensorflow', 'transformers', 'diffusers'];
        if (config.pythonPackages?.some(p => mlPackages.some(ml => p.includes(ml)))) {
            cpuCores = Math.max(cpuCores, 2);
            memoryGB = Math.max(memoryGB, 8);
            storageGB = Math.max(storageGB, 20);
        }

        return {
            cpuCores,
            memoryGB,
            gpuMemoryGB,
            storageGB,
        };
    }
}

// Singleton instance
export const dockerBuilder = new DockerBuilderService();

